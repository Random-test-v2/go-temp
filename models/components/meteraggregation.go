// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package components

type MeterAggregation struct {
	BucketSize *TypesWindowSize `json:"bucket_size,omitzero"`
	// Field is the key in $event.properties on which the aggregation is to be applied
	// For ex if the aggregation type is sum for API usage, the field could be "duration_ms"
	Field *string `json:"field,omitzero"`
	// GroupBy is the property name in event.properties to group by before aggregating.
	// Currently only supported for MAX aggregation with bucket_size.
	// When set, aggregation is applied per unique value of this property within each bucket,
	// then the per-group results are summed to produce the bucket total.
	GroupBy *string `json:"group_by,omitzero"`
	// Multiplier is the multiplier for the aggregation
	// For ex if the aggregation type is sum_with_multiplier for API usage, the multiplier could be 1000
	// to scale up by a factor of 1000. If not provided, it will be null.
	Multiplier *string               `json:"multiplier,omitzero"`
	Type       *TypesAggregationType `json:"type,omitzero"`
}

func (m *MeterAggregation) GetBucketSize() *TypesWindowSize {
	if m == nil {
		return nil
	}
	return m.BucketSize
}

func (m *MeterAggregation) GetField() *string {
	if m == nil {
		return nil
	}
	return m.Field
}

func (m *MeterAggregation) GetGroupBy() *string {
	if m == nil {
		return nil
	}
	return m.GroupBy
}

func (m *MeterAggregation) GetMultiplier() *string {
	if m == nil {
		return nil
	}
	return m.Multiplier
}

func (m *MeterAggregation) GetType() *TypesAggregationType {
	if m == nil {
		return nil
	}
	return m.Type
}
